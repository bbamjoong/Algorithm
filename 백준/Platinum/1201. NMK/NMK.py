import sys
input = sys.stdin.readline

n, m, k = map(int, input().split())

# 설명은 n, m, k = 11, 3, 6 기준으로 함.

# [] -> 한 배열 안에는 숫자를 감소하게 둔다. why? 최대로 감소하는 수열을 처음에 만들어버리면
# 그 이후에는 숫자 배치가 자유롭다

# [] [] [] -> m이 3일 경우 숫자를 총 3덩이로 나누어 한 배열당 거꾸로 배치한다.
# ex)[6,5,4,3,2,1] [8 7] [11 10 9]
# -> 첫번째 배열에서 숫자 하나 선택, 두번째 배열에서 숫자 하나 선택, 세번째 배열에서 숫자 하나 선택 시
# 총 3번 증가하며, 첫번째 배열에서 6번 감소하므로 조건 만족.


# ex) m = 3, k = 6일때 n의 범위는 어떻게 될까?
# [6,5,4,3,2,1] [7] [8] -> n은 적어도 8개 즉 m+k-1개 이상이어야 함
# [6,5,4,3,2,1] [12,11,10,9,8,7] [18,17,16,15,14,13] -> n은 최대 m * k 개임
if n < m+k-1 or n > m*k:
    print(-1)

arr = []
cnt = 1
for i in range(k,0,-1):
    arr.append(i)
    cnt += 1

# ex)6까지 배정했다는 뜻
current = k

# 11개중 6개를 배정했으므로 총 숫자 5개가 남았다.
n = n-k
# [6,5,4,3,2,1] [] []
# 증가하게끔 배치해야하는 배열이 하나 줄었다.
m -= 1

# 배열이 꽉 찼을 경우는 더 진행할 필요가 없다.
while m >= 1:
    # 현재 11개 중 6개의 숫자를 채웠다. 그렇다면 다음 숫자는 7부터 들어간다.
    # 이 때 다음 배열에 들어갈 숫자 개수를 n//m개로 하겠다.
    # 총 n//m(5//2 = 2)2개의 숫자 (current+1, current + n//m) -> 7, 8를 거꾸로 배열한다.
    arr.extend(range(n//m + current, current, -1))
    # 이 후 current를 최신화 해준다.
    current += n//m
    # 총 n//m개의 숫자가 이용되었으므로 n에서 n//m을 빼주고
    # 배열 하나를 채웠으므로 m을 하나 감소시킨다.
    n -= n//m
    m -= 1

print(*arr)